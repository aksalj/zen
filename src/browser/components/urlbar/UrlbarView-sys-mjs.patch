diff --git a/browser/components/urlbar/UrlbarView.sys.mjs b/browser/components/urlbar/UrlbarView.sys.mjs
index fdbab8806fd320f4aacec46a42c8ef953580d00c..40568280c3ba2f0a36f4443a5116430d3c502ec1 100644
--- a/browser/components/urlbar/UrlbarView.sys.mjs
+++ b/browser/components/urlbar/UrlbarView.sys.mjs
@@ -613,7 +613,7 @@ export class UrlbarView {
       !this.input.value ||
       this.input.getAttribute("pageproxystate") == "valid"
     ) {
-      if (!this.isOpen && ["mousedown", "command"].includes(event.type)) {
+      if (!this.isOpen && ["mousedown", "click", "command"].includes(event.type)) {
         // Try to reuse the cached top-sites context. If it's not cached, then
         // there will be a gap of time between when the input is focused and
         // when the view opens that can be perceived as flicker.
@@ -823,6 +823,19 @@ export class UrlbarView {
         // them, resembling tab-to-search. In that case, the input value is
         // still associated with the first result.
         this.input.setResultForCurrentValue(firstResult);
+      } else if (firstResult.payload.zenAction) {
+        this.#selectElement(this.getFirstSelectableElement(), {
+          updateInput: false,
+          setAccessibleFocus:
+            this.controller._userSelectionBehavior == "arrow",
+        });
+        this.window.setTimeout(() => {
+          this.#selectElement(this.getFirstSelectableElement(), {
+            updateInput: false,
+            setAccessibleFocus:
+              this.controller._userSelectionBehavior == "arrow",
+          });
+        }, 150);
       }
     }
 
@@ -1341,7 +1354,7 @@ export class UrlbarView {
           includeHiddenExposures: true,
         });
       let canBeVisible =
-        newSpanCount <= this.#queryContext.maxResults && !seenMisplacedResult;
+        newSpanCount < this.#queryContext.maxResults && !seenMisplacedResult;
       if (result.isHiddenExposure) {
         if (canBeVisible) {
           this.controller.engagementEvent.addExposure(
@@ -3189,7 +3202,7 @@ export class UrlbarView {
   }
 
   #enableOrDisableRowWrap() {
-    let wrap = getBoundsWithoutFlushing(this.input.textbox).width < 650;
+    let wrap = false;
     this.#rows.toggleAttribute("wrap", wrap);
     this.oneOffSearchButtons.container.toggleAttribute("wrap", wrap);
   }
