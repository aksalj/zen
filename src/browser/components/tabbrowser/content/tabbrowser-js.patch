diff --git a/browser/components/tabbrowser/content/tabbrowser.js b/browser/components/tabbrowser/content/tabbrowser.js
index bfba253af3253a8cf547a5d69a1695651fc5c203..fca9c6c918f7d2353edd4f675dd19ca4c4208a50 100644
--- a/browser/components/tabbrowser/content/tabbrowser.js
+++ b/browser/components/tabbrowser/content/tabbrowser.js
@@ -415,11 +415,67 @@
       return this.tabContainer.visibleTabs;
     }
 
+    get _numVisiblePinTabs() {
+      let i = 0;
+      for (let tab of this.tabs) {
+        if (!tab.pinned && !tab.hasAttribute("zen-glance-tab")) {
+          break;
+        }
+        if (!tab.hidden) {
+          i += !tab.hasAttribute("zen-glance-tab");
+        }
+      }
+      return i;
+    }
+
+    get _numVisiblePinTabsWithoutCollapsed() {
+      let i = 0;
+      for (let item of this.tabContainer.ariaFocusableItems) {
+        if (!!item?.classList?.contains("tab-group-label") && item.closest("tab-group").pinned) {
+          i += 1;
+          continue;
+        }
+        if (!item.pinned && !item.hasAttribute("zen-glance-tab")) {
+          break;
+        }
+        if ((!item.group?.hasAttribute("split-view-group") && !item.group?.collapsed) && !item.hidden) {
+          i += !item.hasAttribute("zen-glance-tab");
+        }
+      }
+      return i;
+    }
+
+    get _numZenEssentials() {
+      let i = 0;
+      for (let tab of this.tabs) {
+        if (!tab.hasAttribute("zen-essential") && !tab.hasAttribute("zen-glance-tab")) {
+          break;
+        }
+        i += !tab.hasAttribute("zen-glance-tab");
+      }
+      return i;
+    }
+
+    get _numZenVisibleEssentials() {
+      let i = 0;
+      for (let tab of this.tabs) {
+        if (!tab.hasAttribute("zen-essential") && !tab.hasAttribute("zen-glance-tab")) {
+          break;
+        }
+        if (!tab.hidden) {
+          i += !tab.hasAttribute("zen-glance-tab");
+        }
+      }
+      return i;
+    }
+
     get pinnedTabCount() {
-      for (var i = 0; i < this.tabs.length; i++) {
-        if (!this.tabs[i].pinned) {
+      let i = 0;
+      for (let tab of this.tabs) {
+        if (!tab.pinned && !tab.hasAttribute("zen-glance-tab")) {
           break;
         }
+        i += !tab.hasAttribute("zen-glance-tab");
       }
       return i;
     }
@@ -549,6 +605,7 @@
       this.tabpanels.appendChild(panel);
 
       let tab = this.tabs[0];
+      ZenWorkspaces.handleInitialTab(tab, (!remoteType || remoteType === E10SUtils.PRIVILEGEDABOUT_REMOTE_TYPE) && !Services.prefs.getBoolPref('zen.workspaces.disable_empty_state_for_testing', false));
       tab.linkedPanel = uniqueId;
       this._selectedTab = tab;
       this._selectedBrowser = browser;
@@ -814,11 +871,13 @@
       }
 
       this.showTab(aTab);
-      if (this.tabContainer.verticalMode) {
+      const handled = gZenFolders.handleTabPin(aTab);
+      if (!handled) this.ungroupTab(aTab);
+      if (this.tabContainer.verticalMode && !handled) {
         this.#handleTabMove(aTab, () =>
-          this.verticalPinnedTabsContainer.appendChild(aTab)
+          aTab.hasAttribute("zen-essential") ? document.getElementById("zen-essentials-container").appendChild(aTab) : this.verticalPinnedTabsContainer.insertBefore(aTab, this.verticalPinnedTabsContainer.lastChild)
         );
-      } else {
+      } else if (!handled) {
         this.moveTabTo(aTab, {
           tabIndex: this.pinnedTabCount,
           forceUngrouped: true,
@@ -835,12 +894,15 @@
       }
 
       if (this.tabContainer.verticalMode) {
+        const handled = gZenFolders.handleTabUnpin(aTab);
         this.#handleTabMove(aTab, () => {
           // we remove this attribute first, so that allTabs represents
           // the moving of a tab from the vertical pinned tabs container
           // and back into arrowscrollbox.
           aTab.removeAttribute("pinned");
-          this.tabContainer.arrowScrollbox.prepend(aTab);
+          if (!handled) {
+            ZenWorkspaces.activeWorkspaceStrip.prepend(aTab);
+          }
         });
       } else {
         this.moveTabTo(aTab, {
@@ -1024,6 +1086,8 @@
 
       let LOCAL_PROTOCOLS = ["chrome:", "about:", "resource:", "data:"];
 
+      try {
+      gZenPinnedTabManager.onTabIconChanged(aTab, aIconURL);
       if (
         aIconURL &&
         !aLoadingPrincipal &&
@@ -1034,6 +1098,9 @@
         );
         return;
       }
+      } catch (e) {
+        console.warn(e);
+      }
 
       let browser = this.getBrowserForTab(aTab);
       browser.mIconURL = aIconURL;
@@ -1283,6 +1350,7 @@
       if (!this._previewMode) {
         newTab.recordTimeFromUnloadToReload();
         newTab.updateLastAccessed();
+        newTab.removeAttribute("unread");
         oldTab.updateLastAccessed();
         // if this is the foreground window, update the last-seen timestamps.
         if (this.ownerGlobal == BrowserWindowTracker.getTopWindow()) {
@@ -1435,6 +1503,9 @@
       }
 
       let activeEl = document.activeElement;
+      if (gURLBar._zenHandleUrlbarClose) {
+        gURLBar._zenHandleUrlbarClose(true);
+      }
       // If focus is on the old tab, move it to the new tab.
       if (activeEl == oldTab) {
         newTab.focus();
@@ -1758,7 +1829,8 @@
     }
 
     _setTabLabel(aTab, aLabel, { beforeTabOpen, isContentTitle, isURL } = {}) {
-      if (!aLabel || aLabel.includes("about:reader?")) {
+      gZenPinnedTabManager.onTabLabelChanged(aTab);
+      if (!aLabel || aLabel.includes("about:reader?") || aTab.hasAttribute("zen-has-static-label")) {
         return false;
       }
 
@@ -1866,7 +1938,7 @@
         newIndex = this.selectedTab._tPos + 1;
       }
 
-      if (replace) {
+      if (replace && !(!targetTab && this.selectedTab?.hasAttribute('zen-empty-tab'))) {
         if (this.isTabGroupLabel(targetTab)) {
           throw new Error(
             "Replacing a tab group label with a tab is not supported"
@@ -2130,6 +2202,7 @@
       uriIsAboutBlank,
       userContextId,
       skipLoad,
+      _forZenEmptyTab,
     } = {}) {
       let b = document.createXULElement("browser");
       // Use the JSM global to create the permanentKey, so that if the
@@ -2203,8 +2276,7 @@
         // we use a different attribute name for this?
         b.setAttribute("name", name);
       }
-
-      if (this._allowTransparentBrowser) {
+      if (this._allowTransparentBrowser || _forZenEmptyTab) {
         b.setAttribute("transparent", "true");
       }
 
@@ -2369,7 +2441,7 @@
 
       let panel = this.getPanel(browser);
       let uniqueId = this._generateUniquePanelID();
-      panel.id = uniqueId;
+      if (!panel.id?.startsWith("zen-")) panel.id = uniqueId;
       aTab.linkedPanel = uniqueId;
 
       // Inject the <browser> into the DOM if necessary.
@@ -2428,8 +2500,8 @@
       // If we transitioned from one browser to two browsers, we need to set
       // hasSiblings=false on both the existing browser and the new browser.
       if (this.tabs.length == 2) {
-        this.tabs[0].linkedBrowser.browsingContext.hasSiblings = true;
-        this.tabs[1].linkedBrowser.browsingContext.hasSiblings = true;
+        if (this.tabs[0].linkedBrowser.browsingContext) this.tabs[0].linkedBrowser.browsingContext.hasSiblings = true;
+        if (this.tabs[1].linkedBrowser.browsingContext) this.tabs[1].linkedBrowser.browsingContext.hasSiblings = true;
       } else {
         aTab.linkedBrowser.browsingContext.hasSiblings = this.tabs.length > 1;
       }
@@ -2657,6 +2729,7 @@
         schemelessInput,
         hasValidUserGestureActivation = false,
         textDirectiveUserActivation = false,
+        _forZenEmptyTab,
       } = {}
     ) {
       // all callers of addTab that pass a params object need to pass
@@ -2667,6 +2740,12 @@
         );
       }
 
+      let hasZenDefaultUserContextId = false;
+      let zenForcedWorkspaceId = undefined;
+      if (typeof ZenWorkspaces !== "undefined" && !_forZenEmptyTab) {
+        [userContextId, hasZenDefaultUserContextId, zenForcedWorkspaceId] = ZenWorkspaces.getContextIdIfNeeded(userContextId, fromExternal, allowInheritPrincipal);
+      }
+
       if (!UserInteraction.running("browser.tabs.opening", window)) {
         UserInteraction.start("browser.tabs.opening", "initting", window);
       }
@@ -2730,6 +2809,16 @@
           noInitialLabel,
           skipBackgroundNotify,
         });
+        if (hasZenDefaultUserContextId) {
+          t.setAttribute("zenDefaultUserContextId", "true");
+        }
+        if (zenForcedWorkspaceId !== undefined) {
+          t.setAttribute("zen-workspace-id", zenForcedWorkspaceId);
+          t.setAttribute("change-workspace", "")
+        }
+        if (_forZenEmptyTab) {
+          t.setAttribute("zen-empty-tab", "true");
+        }
         if (insertTab) {
           if (typeof index == "number") {
             elementIndex = this.#tabIndexToElementIndex(index);
@@ -2756,6 +2845,7 @@
           initialBrowsingContextGroupId,
           openWindowInfo,
           skipLoad,
+          _forZenEmptyTab,
         }));
 
         if (focusUrlBar) {
@@ -2875,6 +2965,9 @@
         }
       }
 
+      if (typeof window.gZenVerticalTabsManager !== "undefined") {
+        gZenVerticalTabsManager.animateTab(t);
+      }
       // Additionally send pinned tab events
       if (pinned) {
         this._notifyPinnedStatus(t);
@@ -2922,12 +3015,15 @@
      * @param {string} [label=]
      * @returns {MozTabbrowserTabGroup}
      */
-    _createTabGroup(id, color, collapsed, label = "") {
+    _createTabGroup(id, color, collapsed, label = "", pinned = false, essential = false, splitViewGroup = false) {
       let group = document.createXULElement("tab-group", { is: "tab-group" });
       group.id = id;
       group.collapsed = collapsed;
       group.color = color;
       group.label = label;
+      group.pinned = pinned;
+      group.essential = essential;
+      if (splitViewGroup) group.setAttribute('split-view-group', true);
       return group;
     }
 
@@ -2970,6 +3066,7 @@
         insertBefore = null,
         isUserTriggered = false,
         telemetryUserCreateSource = "unknown",
+        forSplitView = false,
       } = {}
     ) {
       if (!tabs?.length) {
@@ -2988,7 +3085,12 @@
         id = `${Date.now()}-${Math.round(Math.random() * 100)}`;
       }
       let group = this._createTabGroup(id, color, false, label);
-      this.tabContainer.insertBefore(
+      if (forSplitView) {
+        group.setAttribute('split-view-group', true);
+      }
+      group.essential = tabs.some(tab => tab.hasAttribute("essential"));
+      group.pinned = group.essential || tabs.some(tab => tab.pinned);
+      ((insertBefore?.group ?? insertBefore).parentNode).insertBefore(
         group,
         insertBefore?.group ?? insertBefore
       );
@@ -3318,6 +3420,7 @@
         initialBrowsingContextGroupId,
         openWindowInfo,
         skipLoad,
+        _forZenEmptyTab
       }
     ) {
       // If we don't have a preferred remote type, and we have a remote
@@ -3381,6 +3484,7 @@
           openWindowInfo,
           name,
           skipLoad,
+          _forZenEmptyTab
         });
       }
 
@@ -3559,6 +3663,27 @@
         ) {
           tabWasReused = true;
           tab = this.selectedTab;
+          if (tabData.zenWorkspace) {
+            tab.setAttribute("zen-workspace-id", tabData.zenWorkspace);
+          }
+          if (tabData.zenIsEmpty) {
+            tab.setAttribute("zen-empty-tab", "true");
+          }
+          if (tabData.zenHasStaticLabel) {
+            tab.setAttribute("zen-has-static-label", "true");
+          }
+          if (tabData.zenPinnedId) {
+            tab.setAttribute("zen-pin-id", tabData.zenPinnedId);
+          }
+          if (tabData.zenEssential) {
+            tab.setAttribute("zen-essential", "true");
+          }
+          if (tabData.zenDefaultUserContextId) {
+            tab.setAttribute("zenDefaultUserContextId", "true");
+          }
+          if (tabData.zenPinnedEntry) {
+            tab.setAttribute("zen-pinned-entry", tabData.zenPinnedEntry);
+          }
           if (!tabData.pinned) {
             this.unpinTab(tab);
           } else {
@@ -3607,8 +3732,28 @@
             skipLoad: true,
             preferredRemoteType,
           });
-
-          if (select) {
+          if (tabData.zenWorkspace) {
+            tab.setAttribute("zen-workspace-id", tabData.zenWorkspace);
+          }
+          if (tabData.zenPinnedId) {
+            tab.setAttribute("zen-pin-id", tabData.zenPinnedId);
+          }
+          if (tabData.zenIsEmpty) {
+            tab.setAttribute("zen-empty-tab", "true");
+          }
+          if (tabData.zenHasStaticLabel) {
+            tab.setAttribute("zen-has-static-label", "true");
+          }
+          if (tabData.zenEssential) {
+            tab.setAttribute("zen-essential", "true");
+          }
+          if (tabData.zenDefaultUserContextId) {
+            tab.setAttribute("zenDefaultUserContextId", "true");
+          }
+          if (tabData.zenPinnedEntry) {
+            tab.setAttribute("zen-pinned-entry", tabData.zenPinnedEntry);
+          }
+          if (select && !tabData.pinned) {
             tabToSelect = tab;
           }
         }
@@ -3620,8 +3765,8 @@
           // inserted in the DOM. If the tab is not yet in the DOM,
           // just insert it in the right place from the start.
           if (!tab.parentNode) {
-            tab._tPos = this.pinnedTabCount;
-            this.tabContainer.insertBefore(tab, this.tabs[this.pinnedTabCount]);
+            tab._tPos = this._numVisiblePinTabs;
+            this.tabContainer.insertBefore(tab, this.tabs[this._numVisiblePinTabs]);
             tab.toggleAttribute("pinned", true);
             this.tabContainer._invalidateCachedTabs();
             // Then ensure all the tab open/pinning information is sent.
@@ -3631,7 +3776,8 @@
             // needs calling:
             shouldUpdateForPinnedTabs = true;
           }
-        } else if (tabData.groupId) {
+        }
+        if (tabData.groupId) {
           let { groupId } = tabData;
           const tabGroup = tabGroupWorkingData.get(groupId);
           // if a tab refers to a tab group we don't know, skip any group
@@ -3645,7 +3791,10 @@
                 tabGroup.stateData.id,
                 tabGroup.stateData.color,
                 tabGroup.stateData.collapsed,
-                tabGroup.stateData.name
+                tabGroup.stateData.name,
+                tabGroup.stateData.pinned,
+                tabGroup.stateData.essential,
+                tabGroup.stateData.splitView,
               );
               tabsFragment.appendChild(tabGroup.node);
             }
@@ -3696,6 +3845,9 @@
         this.selectedTab = tabToSelect;
         this.removeTab(leftoverTab);
       }
+      else {
+        this.selectedTab._possiblyEmpty = this.selectedTab.isEmpty; // Not needed, but just in case.
+      }
 
       if (tabs.length > 1 || !tabs[0].selected) {
         this._updateTabsAfterInsert();
@@ -3882,7 +4034,7 @@
       // Ensure we have an index if one was not provided.
       if (typeof index != "number") {
         // Move the new tab after another tab if needed, to the end otherwise.
-        index = Infinity;
+        index = Services.prefs.getBoolPref("zen.view.show-newtab-button-top") ? this.pinnedTabCount : Infinity;
         if (
           !bulkOrderedOpen &&
           ((openerTab &&
@@ -3928,18 +4080,18 @@
 
       // Ensure index is within bounds.
       if (tab.pinned) {
-        index = Math.max(index, 0);
-        index = Math.min(index, this.pinnedTabCount);
+        index = Math.max(index, tab.hasAttribute("zen-essential") ? 0 : this._numZenEssentials);
+        index = Math.min(index, tab.hasAttribute("zen-essential") ? this._numZenEssentials : this.pinnedTabCount);
       } else {
         index = Math.max(index, this.pinnedTabCount);
         index = Math.min(index, this.tabContainer.ariaFocusableItems.length);
       }
 
       /** @type {MozTabbrowserTab|undefined} */
-      let itemAfter = this.tabContainer.ariaFocusableItems.at(index);
+      let itemAfter = this.tabContainer.ariaFocusableItems.filter(tab => !tab.hasAttribute("zen-glance-tab")).at(index);
       this.tabContainer._invalidateCachedTabs();
 
-      if (tabGroup) {
+      if (tabGroup && !tabGroup.hasAttribute("split-view-group")) {
         if (this.isTab(itemAfter) && itemAfter.group == tabGroup) {
           // Place at the front of, or between tabs in, the same tab group
           this.tabContainer.insertBefore(tab, itemAfter);
@@ -4260,6 +4412,9 @@
         return;
       }
 
+      for (let tab of selectedTabs) {
+        gZenPinnedTabManager._removePinnedAttributes(tab, true);
+      }
       this.removeTabs(selectedTabs, { telemetrySource });
     }
 
@@ -4512,6 +4667,7 @@
         telemetrySource,
       } = {}
     ) {
+      tabs = tabs.filter(tab => !tab.hasAttribute("zen-empty-tab"));
       // When 'closeWindowWithLastTab' pref is enabled, closing all tabs
       // can be considered equivalent to closing the window.
       if (
@@ -4596,6 +4752,7 @@
         if (lastToClose) {
           this.removeTab(lastToClose, aParams);
         }
+        gZenUIManager.onTabClose(undefined);
       } catch (e) {
         console.error(e);
       }
@@ -4620,6 +4777,7 @@
         telemetrySource,
       } = {}
     ) {
+      gZenUIManager.saveScrollbarState();
       if (UserInteraction.running("browser.tabs.opening", window)) {
         UserInteraction.finish("browser.tabs.opening", window);
       }
@@ -4633,6 +4791,12 @@
         aTab._closeTimeNoAnimTimerId = Glean.browserTabclose.timeNoAnim.start();
       }
 
+      if (ZenWorkspaces.workspaceEnabled) {
+        let newTab = ZenWorkspaces.handleTabBeforeClose(aTab);
+        if (newTab) {
+          this.selectedTab = newTab;
+        }
+      }
       // Handle requests for synchronously removing an already
       // asynchronously closing tab.
       if (!animate && aTab.closing) {
@@ -4647,7 +4811,9 @@
       // frame created for it (for example, by updating the visually selected
       // state).
       let tabWidth = window.windowUtils.getBoundsWithoutFlushing(aTab).width;
-
+      if (gZenGlanceManager.manageTabClose(aTab)) {
+        return;
+      }
       if (
         !this._beginRemoveTab(aTab, {
           closeWindowFastpath: true,
@@ -4810,7 +4976,7 @@
           closeWindowWithLastTab != null
             ? closeWindowWithLastTab
             : !window.toolbar.visible ||
-              Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab");
+            Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab") && !ZenWorkspaces._isClosingWindow && !ZenWorkspaces._removedByStartupPage;
 
         if (closeWindow) {
           // We've already called beforeunload on all the relevant tabs if we get here,
@@ -4834,6 +5000,7 @@
 
         newTab = true;
       }
+      ZenWorkspaces._removedByStartupPage = false;
       aTab._endRemoveArgs = [closeWindow, newTab];
 
       // swapBrowsersAndCloseOther will take care of closing the window without animation.
@@ -4873,9 +5040,7 @@
       aTab._mouseleave();
 
       if (newTab) {
-        this.addTrustedTab(BROWSER_NEW_TAB_URL, {
-          skipAnimation: true,
-        });
+        ZenWorkspaces.selectEmptyTab(BROWSER_NEW_TAB_URL);
       } else {
         TabBarVisibility.update();
       }
@@ -5004,6 +5169,8 @@
         this.tabs[i]._tPos = i;
       }
 
+      ZenWorkspaces.updateTabsContainers();
+
       if (!this._windowIsClosing) {
         if (wasPinned) {
           this.tabContainer._positionPinnedTabs();
@@ -5129,8 +5296,8 @@
       return closedCount;
     }
 
-    async explicitUnloadTabs(tabs) {
-      let unloadBlocked = await this.runBeforeUnloadForTabs(tabs);
+    async explicitUnloadTabs(tabs, skipPermitUnload = false) {
+      let unloadBlocked = skipPermitUnload ? false : await this.runBeforeUnloadForTabs(tabs);
       if (unloadBlocked) {
         return;
       }
@@ -5230,13 +5397,13 @@
         !excludeTabs.has(aTab.owner) &&
         Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")
       ) {
-        return aTab.owner;
+        return ZenWorkspaces.findTabToBlur(aTab.owner);
       }
 
       // Try to find a remaining tab that comes after the given tab
       let remainingTabs = Array.prototype.filter.call(
         this.visibleTabs,
-        tab => !excludeTabs.has(tab)
+        tab => !excludeTabs.has(tab) && ZenWorkspaces._shouldChangeToTab(tab)
       );
 
       let tab = this.tabContainer.findNextTab(aTab, {
@@ -5252,7 +5419,7 @@
       }
 
       if (tab) {
-        return tab;
+        return ZenWorkspaces.findTabToBlur(tab);
       }
 
       // If no qualifying visible tab was found, see if there is a tab in
@@ -5273,7 +5440,7 @@
         });
       }
 
-      return tab;
+      return ZenWorkspaces.findTabToBlur(tab);
     }
 
     _blurTab(aTab) {
@@ -5674,10 +5841,10 @@
       SessionStore.deleteCustomTabValue(aTab, "hiddenBy");
     }
 
-    hideTab(aTab, aSource) {
+    hideTab(aTab, aSource, forZenWorkspaces = false) {
       if (
         aTab.hidden ||
-        aTab.pinned ||
+        (aTab.pinned && !forZenWorkspaces) ||
         aTab.selected ||
         aTab.closing ||
         // Tabs that are sharing the screen, microphone or camera cannot be hidden.
@@ -5971,7 +6138,7 @@
 
       // Don't allow mixing pinned and unpinned tabs.
       if (this.isTab(element) && element.pinned) {
-        tabIndex = Math.min(tabIndex, this.pinnedTabCount - 1);
+        tabIndex = aTab.hasAttribute('zen-essential') ? Math.min(tabIndex, this._numZenEssentials - 1) : Math.min(tabIndex, this.pinnedTabCount - 1);
       } else {
         tabIndex = Math.max(tabIndex, this.pinnedTabCount);
       }
@@ -5998,9 +6165,16 @@
         element,
         () => {
           let neighbor = this.tabs[tabIndex];
-          if (forceUngrouped && neighbor.group) {
+          const _tPos = element._tPos;
+          if ((forceStandaloneTab && neighbor.group) || neighbor.group?.hasAttribute("split-view-group")) {
             neighbor = neighbor.group;
           }
+          if (element.group?.hasAttribute("split-view-group")) {
+            element = element.group;
+          }
+          if (element.group?.hasAttribute("split-view-group") && neighbor == element.group) {
+            return;
+          }
           if (neighbor && this.isTab(element) && tabIndex > element._tPos) {
             neighbor.after(element);
           } else {
@@ -6069,7 +6243,9 @@
           targetElement = targetElement.group;
         }
       }
-
+      if (tab.group?.hasAttribute("split-view-group")) {
+        tab = tab.group;
+      }
       // Don't allow mixing pinned and unpinned tabs.
       if (element.pinned && !targetElement?.pinned) {
         targetElement = this.tabs[this.pinnedTabCount - 1];
@@ -6079,7 +6255,13 @@
         moveBefore = true;
       }
 
+      if (targetElement?.group?.hasAttribute("split-view-group")) {
+        targetElement = targetElement.group;
+      }
       let getContainer = () => {
+        if (tab.hasAttribute("zen-essential")) {
+          return document.getElementById("zen-essentials-container");
+        }
         if (element.pinned && this.tabContainer.verticalMode) {
           return this.tabContainer.verticalPinnedTabsContainer;
         }
@@ -6139,7 +6321,7 @@
       if (!this.isTab(aTab)) {
         throw new Error("Can only move a tab into a tab group");
       }
-      if (aTab.pinned) {
+      if (aTab.pinned != !!aGroup.pinned) {
         return;
       }
       if (aTab.group && aTab.group.id === aGroup.id) {
@@ -6233,6 +6415,10 @@
 
       moveActionCallback();
 
+      ZenWorkspaces._makeSureEmptyTabIsLast();
+      gZenViewSplitter._maybeRemoveFakeBrowser(false);
+      gZenViewSplitter._canDrop = false;
+
       // Clear tabs cache after moving nodes because the order of tabs may have
       // changed.
       this.tabContainer._invalidateCachedTabs();
@@ -6290,7 +6476,7 @@
         createLazyBrowser,
       };
 
-      let numPinned = this.pinnedTabCount;
+      let numPinned = this._numVisiblePinTabs;
       if (
         elementIndex < numPinned ||
         (aTab.pinned && elementIndex == numPinned)
@@ -7050,7 +7236,7 @@
             // preventDefault(). It will still raise the window if appropriate.
             break;
           }
-          this.selectedTab = tab;
+          ZenWorkspaces.switchTabIfNeeded(tab);
           window.focus();
           aEvent.preventDefault();
           break;
@@ -7951,6 +8137,7 @@
             aWebProgress.isTopLevel
           ) {
             this.mTab.setAttribute("busy", "true");
+            if (!this.mTab.selected) this.mTab.setAttribute("unread", "true");
             gBrowser._tabAttrModified(this.mTab, ["busy"]);
             this.mTab._notselectedsinceload = !this.mTab.selected;
           }
@@ -8924,7 +9111,7 @@ var TabContextMenu = {
     );
     contextUnpinSelectedTabs.hidden =
       !this.contextTab.pinned || !this.multiselected;
-
+    gZenPinnedTabManager.updatePinnedTabContextMenu(this.contextTab);
     // Move Tab items
     let contextMoveTabOptions = document.getElementById(
       "context_moveTabOptions"
@@ -8958,7 +9145,7 @@ var TabContextMenu = {
     let isFirstTab =
       !this.contextTabs[0].group &&
       (this.contextTabs[0] == visibleTabs[0] ||
-        this.contextTabs[0] == visibleTabs[gBrowser.pinnedTabCount]);
+      this.contextTabs[0] == visibleTabs[gBrowser._numVisiblePinTabs]);
     contextMoveTabToStart.disabled = isFirstTab && allSelectedTabsAdjacent;
 
     document.getElementById("context_openTabInWindow").disabled =
@@ -9193,6 +9380,7 @@ var TabContextMenu = {
         telemetrySource: gBrowser.TabMetrics.METRIC_SOURCE.TAB_STRIP,
       });
     } else {
+      gZenPinnedTabManager._removePinnedAttributes(this.contextTab, true);
       gBrowser.removeTab(this.contextTab, {
         animate: true,
         telemetrySource: gBrowser.TabMetrics.METRIC_SOURCE.TAB_STRIP,
