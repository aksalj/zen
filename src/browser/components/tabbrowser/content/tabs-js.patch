diff --git a/browser/components/tabbrowser/content/tabs.js b/browser/components/tabbrowser/content/tabs.js
index e2b27db6c13278defea3bcc7606a8da54e7d001c..016d58789918235cc3a41f33ee402c2c3b65f80b 100644
--- a/browser/components/tabbrowser/content/tabs.js
+++ b/browser/components/tabbrowser/content/tabs.js
@@ -332,7 +332,7 @@
       // and we're not hitting the scroll buttons.
       if (
         event.button != 0 ||
-        event.target != this.arrowScrollbox ||
+        !event.target.classList.contains("zen-workspace-normal-tabs-section") ||
         event.composedTarget.localName == "toolbarbutton"
       ) {
         return;
@@ -413,7 +413,6 @@
             });
           }
         } else if (isTabGroupLabel(event.target)) {
-          event.target.group.saveAndClose();
         } else if (
           event.originalTarget.closest("scrollbox") &&
           !Services.prefs.getBoolPref(
@@ -686,7 +685,7 @@
       if (this.#isContainerVerticalPinnedGrid(tab)) {
         // In expanded vertical mode, the max number of pinned tabs per row is dynamic
         // Set this before adjusting dragged tab's position
-        let pinnedTabs = this.visibleTabs.slice(0, gBrowser.pinnedTabCount);
+        let pinnedTabs = this.ariaFocusableItems.slice(0, gBrowser._numZenEssentials);
         let tabsPerRow = 0;
         let position = RTL_UI
           ? window.windowUtils.getBoundsWithoutFlushing(
@@ -851,7 +850,7 @@
       let dropEffect = this.getDropEffectForTabDrag(event);
       let isMovingInTabStrip = !fromTabList && dropEffect == "move";
       let collapseTabGroupDuringDrag =
-        isMovingInTabStrip && isTabGroupLabel(tab) && !tab.group.collapsed;
+        isMovingInTabStrip && isTabGroupLabel(tab) && (!tab.group.collapsed || tab.group.hasAttribute("has-active"));
 
       tab._dragData = {
         offsetX: this.verticalMode
@@ -861,7 +860,7 @@
           ? event.screenY - window.screenY - tabOffset
           : event.screenY - window.screenY,
         scrollPos:
-          this.verticalMode && tab.pinned
+          this.verticalMode && tab.pinned && false
             ? this.pinnedTabsContainer.scrollPosition
             : this.arrowScrollbox.scrollPosition,
         screenX: event.screenX,
@@ -886,6 +885,7 @@
         if (tab.multiselected) {
           this.#moveTogetherSelectedTabs(tab);
         } else if (collapseTabGroupDuringDrag) {
+          gZenFolders.collapseVisibleTab(tab.group);
           tab.group.collapsed = true;
         }
       }
@@ -932,6 +932,10 @@
       }
 
       let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
+      if (draggedTab && dropEffect === "move") {
+        gZenPinnedTabManager.applyDragoverClass(event, draggedTab);
+        gZenViewSplitter.onBrowserDragEndToSplit(event);
+      }
       if (
         (dropEffect == "move" || dropEffect == "copy") &&
         document == draggedTab.ownerDocument &&
@@ -1059,7 +1063,9 @@
         isTabGroupLabel(draggedTab) &&
         draggedTab._dragData?.expandGroupOnDrop
       ) {
-        draggedTab.group.collapsed = false;
+        const isActive = draggedTab.group.hasAttribute("has-active");
+        draggedTab.group.collapsed = isActive;
+        if (isActive) gZenFolders.expandVisibleTab(draggedTab.group);
       }
     }
 
@@ -1095,6 +1101,18 @@
 
       this._tabDropIndicator.hidden = true;
       event.stopPropagation();
+      if (draggedTab?.hasAttribute("zen-has-splitted")) {
+        draggedTab.removeAttribute("zen-has-splitted");
+        draggedTab._visuallySelected = false;
+      }
+      if (draggedTab && dropEffect == "move") {
+        let moved = gZenPinnedTabManager.moveToAnotherTabContainerIfNecessary(event, movingTabs);
+
+        if (moved) {
+          this.finishMoveTogetherSelectedTabs(draggedTab);
+          return;
+        }
+      }
       if (draggedTab && dropEffect == "copy") {
         let duplicatedDraggedTab;
         let duplicatedTabs = [];
@@ -1119,8 +1137,9 @@
         let translateOffsetY = oldTranslateY % tabHeight;
         let newTranslateX = oldTranslateX - translateOffsetX;
         let newTranslateY = oldTranslateY - translateOffsetY;
-        let isPinned = draggedTab.pinned;
-        let numPinned = gBrowser.pinnedTabCount;
+        let isPinned = draggedTab?.group ? draggedTab.group.pinned : draggedTab.pinned;
+        let numPinned = gBrowser._numVisiblePinTabsWithoutCollapsed;
+        let essential = draggedTab.hasAttribute("zen-essential");
 
         if (this.#isContainerVerticalPinnedGrid(draggedTab)) {
           // Update both translate axis for pinned vertical expanded tabs
@@ -1136,8 +1155,8 @@
           }
         } else {
           let tabs = this.ariaFocusableItems.slice(
-            isPinned ? 0 : numPinned,
-            isPinned ? numPinned : undefined
+            isPinned ? (essential ? 0 : gBrowser._numZenEssentials) : numPinned,
+            isPinned ? (essential ? gBrowser._numZenEssentials : numPinned) : undefined
           );
           let size = this.verticalMode ? "height" : "width";
           let screenAxis = this.verticalMode ? "screenY" : "screenX";
@@ -1178,11 +1197,9 @@
         }
 
         let shouldPin =
-          numPinned &&
-          this.pinnedTabsContainer.contains(event.target) &&
-          !draggedTab.pinned;
+          false;
         let shouldUnpin =
-          this.arrowScrollbox.contains(event.target) && draggedTab.pinned;
+          false;
         let shouldTranslate =
           !gReduceMotion &&
           !shouldCreateGroupOnDrop &&
@@ -1195,6 +1212,7 @@
             (oldTranslateY && oldTranslateY != newTranslateY);
         } else if (this.verticalMode) {
           shouldTranslate &&= oldTranslateY && oldTranslateY != newTranslateY;
+          shouldTranslate = false;
         } else {
           shouldTranslate &&= oldTranslateX && oldTranslateX != newTranslateX;
         }
@@ -1376,6 +1394,7 @@
 
           let nextItem = this.ariaFocusableItems[newIndex];
           let tabGroup = isTab(nextItem) && nextItem.group;
+          if (gZenViewSplitter.handleTabDrop(event, urls, replace, inBackground)) return;
           gBrowser.loadTabs(urls, {
             inBackground,
             replace,
@@ -1408,6 +1427,17 @@
 
       this.finishMoveTogetherSelectedTabs(draggedTab);
       this.finishAnimateTabMove();
+
+      if (!dt.mozUserCancelled && dt.dropEffect == "none" && !this._isCustomizing) {
+        const moved = gZenViewSplitter.moveTabToSplitView(event, draggedTab);
+        if (moved) {
+          delete draggedTab._dragData;
+          return;
+        }
+      } else if (dt.mozUserCancelled) {
+        if (gZenViewSplitter._lastOpenedTab) gZenViewSplitter._lastOpenedTab._visuallySelected = false;
+      }
+
       this.#expandGroupOnDrop(draggedTab);
       this.#resetTabsAfterDrop(draggedTab.ownerDocument);
 
@@ -1577,7 +1607,6 @@
 
       this.toggleAttribute("overflow", true);
       this._updateCloseButtons();
-      this._handleTabSelect(true);
 
       document
         .getElementById("tab-preview-panel")
@@ -1635,7 +1664,7 @@
     }
 
     get newTabButton() {
-      return this.querySelector("#tabs-newtab-button");
+      return gZenWorkspaces.activeWorkspaceStrip.querySelector("#tabs-newtab-button");
     }
 
     get verticalMode() {
@@ -1651,6 +1680,7 @@
     }
 
     get overflowing() {
+      gZenWorkspaces.updateOverflowingTabs();
       return this.hasAttribute("overflow");
     }
 
@@ -1659,26 +1689,54 @@
       if (this.#allTabs) {
         return this.#allTabs;
       }
-      let children = Array.from(this.arrowScrollbox.children);
+      let children = gZenWorkspaces.tabboxChildren;
       // remove arrowScrollbox periphery element
       children.pop();
 
       // explode tab groups
       // Iterate backwards over the array to preserve indices while we modify
       // things in place
-      for (let i = children.length - 1; i >= 0; i--) {
-        if (children[i].tagName == "tab-group") {
-          children.splice(i, 1, ...children[i].tabs);
+      const pinnedTabs = [...gZenWorkspaces.getCurrentEssentialsContainer().children, ...this.pinnedTabsContainer.children];
+      const expandTabs = (tabs) => {
+        for (let i = tabs.length - 1; i >= 0; i--) {
+          const tab = tabs[i];
+          if (isTabGroup(tab)) {
+            // remove the group from the list
+            tabs.splice(i, 1);
+            // add the tabs in the group to the list
+            tabs.splice(i, 0, ...tab.tabs);
+          }
         }
       }
-
-      this.#allTabs = [...this.pinnedTabsContainer.children, ...children];
+      expandTabs(pinnedTabs);
+      expandTabs(children);
+      const allTabs = [
+        ...pinnedTabs,
+        ...children,
+      ];
+      const lastPinnedTabIdx = pinnedTabs.length - 1;
+      let i = 0;
+      for (const tab of [...allTabs]) {
+        // add glance tabs (tabs inside tabs) to the list
+        const glanceTab = tab.glanceTab;
+        if (glanceTab) {
+          // insert right after the parent tab. note: it must be inserted before
+          // the last pinned tab so it can be inserted in the correct order
+          allTabs.splice(Math.max(i++ + 1, lastPinnedTabIdx), 0, glanceTab);
+        } else if (tab.classList.contains("pinned-tabs-container-separator")) {
+          // remove the separator from the list
+          allTabs.splice(i, 1);
+          i--;
+        }
+        i++;
+      }
+      this.#allTabs = allTabs;
       return this.#allTabs;
     }
 
     get allGroups() {
       let children = Array.from(this.arrowScrollbox.children);
-      return children.filter(node => node.tagName == "tab-group");
+      return gZenWorkspaces.allTabGroups;
     }
 
     /**
@@ -1745,32 +1803,27 @@
 
       let elementIndex = 0;
 
-      for (let i = 0; i < this.pinnedTabsContainer.childElementCount; i++) {
-        this.pinnedTabsContainer.children[i].elementIndex = elementIndex++;
-      }
-      let children = Array.from(this.arrowScrollbox.children);
+      let children = gZenWorkspaces.tabboxChildrenWithoutEmpty;
 
       let focusableItems = [];
-      for (let child of children) {
+      for (let child of [...gZenWorkspaces.getCurrentEssentialsContainer().children, ...this.pinnedTabsContainer.children, ...children]) {
         if (isTab(child) && child.visible) {
           child.elementIndex = elementIndex++;
           focusableItems.push(child);
         } else if (isTabGroup(child)) {
           child.labelElement.elementIndex = elementIndex++;
           focusableItems.push(child.labelElement);
-
-          let visibleTabsInGroup = child.tabs.filter(tab => tab.visible);
-          visibleTabsInGroup.forEach(tab => {
-            tab.elementIndex = elementIndex++;
-          });
+          if (!child.hasAttribute("split-view-group")) {
+            let visibleTabsInGroup = child.childGroupsAndTabs.filter(tab => tab.visible);
+            visibleTabsInGroup.forEach(tab => {
+              tab.elementIndex = elementIndex++;
+            });
           focusableItems.push(...visibleTabsInGroup);
+          }
         }
       }
 
-      this.#focusableItems = [
-        ...this.pinnedTabsContainer.children,
-        ...focusableItems,
-      ];
+      this.#focusableItems = focusableItems;
 
       return this.#focusableItems;
     }
@@ -1778,6 +1831,7 @@
     _invalidateCachedTabs() {
       this.#allTabs = null;
       this._invalidateCachedVisibleTabs();
+      gZenWorkspaces._allStoredTabs = null;
     }
 
     _invalidateCachedVisibleTabs() {
@@ -1793,8 +1847,8 @@
     #isContainerVerticalPinnedGrid(tab) {
       return (
         this.verticalMode &&
-        tab.hasAttribute("pinned") &&
-        this.hasAttribute("expanded") &&
+        (tab.hasAttribute("zen-essential")) &&
+        (this.hasAttribute("expanded") || document.documentElement.hasAttribute("zen-sidebar-expanded")) &&
         !this.expandOnHover
       );
     }
@@ -1810,7 +1864,7 @@
 
       if (node == null) {
         // We have a container for non-tab elements at the end of the scrollbox.
-        node = this.arrowScrollbox.lastChild;
+        node = gZenWorkspaces.activeWorkspaceStrip.lastChild;
       }
 
       node.before(tab);
@@ -1905,7 +1959,7 @@
           // There are separate "new tab" buttons for horizontal tabs toolbar, vertical tabs and
           // for when the tab strip is overflowed (which is shared by vertical and horizontal tabs);
           // Attach the long click popup to all of them.
-          const newTab = document.getElementById("new-tab-button");
+          const newTab = gZenWorkspaces.activeWorkspaceStrip.querySelector("#tabs-newtab-button");
           const newTab2 = this.newTabButton;
           const newTabVertical = document.getElementById(
             "vertical-tabs-newtab-button"
@@ -2000,10 +2054,12 @@
 
     _handleTabSelect(aInstant) {
       let selectedTab = this.selectedItem;
+      if (!selectedTab) return;
       if (this.overflowing) {
         this.arrowScrollbox.ensureElementIsVisible(selectedTab, aInstant);
       }
 
+      gZenCompactModeManager.flashSidebarIfNecessary(aInstant);
       selectedTab._notselectedsinceload = false;
     }
 
@@ -2140,6 +2196,16 @@
       when the tab is first selected to be dragged.
     */
     #updateTabStylesOnDrag(tab) {
+      let { movingTabs: zenMovingTabs } = tab._dragData;
+      for (let movingTab of zenMovingTabs.slice(zenMovingTabs.findIndex(t => t._tPos == tab._tPos))) {
+        if (isTabGroupLabel(tab)) {
+          movingTab = movingTab.parentElement;
+        }
+        // "dragtarget" contains the following rules which must only be set AFTER the above
+        // elements have been adjusted. {z-index: 3 !important, position: absolute !important}
+        movingTab.setAttribute("zen-dragtarget", "");
+      }
+      return;
       let isPinned = tab.pinned;
       let numPinned = gBrowser.pinnedTabCount;
       let allTabs = this.ariaFocusableItems;
@@ -2398,7 +2464,7 @@
         return;
       }
 
-      let tabs = this.visibleTabs.slice(0, gBrowser.pinnedTabCount);
+      let tabs = this.ariaFocusableItems.slice(0, gBrowser._numZenEssentials);
 
       let directionX = screenX > dragData.animLastScreenX;
       let directionY = screenY > dragData.animLastScreenY;
@@ -2407,6 +2473,8 @@
 
       let { width: tabWidth, height: tabHeight } =
         draggedTab.getBoundingClientRect();
+      tabWidth += 4; // Add 4px to account for the gap
+      tabHeight += 4;
       let shiftSizeX = tabWidth * movingTabs.length;
       let shiftSizeY = tabHeight;
       dragData.tabWidth = tabWidth;
@@ -2443,8 +2511,8 @@
       let lastBoundX =
         lastTabInRow.screenX +
         lastTabInRow.getBoundingClientRect().width -
-        (lastMovingTabScreenX + tabWidth);
-      let lastBoundY = periphery.screenY - (lastMovingTabScreenY + tabHeight);
+        (lastMovingTabScreenX + tabWidth) + 4;
+      let lastBoundY = 0;
       translateX = Math.min(Math.max(translateX, firstBoundX), lastBoundX);
       translateY = Math.min(Math.max(translateY, firstBoundY), lastBoundY);
 
@@ -2560,7 +2628,7 @@
       }
 
       dragData.animDropElementIndex = newIndex;
-      dragData.dropElement = tabs[newIndex];
+      dragData.dropElement = tabs[Math.min(newIndex, tabs.length - 1)];
       dragData.dropBefore = newIndex < tabs.length;
 
       // Shift background tabs to leave a gap where the dragged tab
@@ -2593,13 +2661,18 @@
 
       this.#clearDragOverCreateGroupTimer();
 
-      let isPinned = draggedTab.pinned;
-      let numPinned = gBrowser.pinnedTabCount;
+      let isPinned = draggedTab?.group ? draggedTab.group.pinned : draggedTab.pinned;
+      let numPinned = gBrowser._numVisiblePinTabsWithoutCollapsed;
+      let essential = draggedTab.hasAttribute("zen-essential");
+      const isDraggingFolder = isTabGroupLabel(draggedTab) && draggedTab.group?.isZenFolder;
       let allTabs = this.ariaFocusableItems;
       let tabs = allTabs.slice(
-        isPinned ? 0 : numPinned,
-        isPinned ? numPinned : undefined
+        (isPinned && essential) ? 0 : gBrowser._numZenEssentials,
+        isPinned ? (essential ? gBrowser._numZenEssentials : (isDraggingFolder ? numPinned : undefined)) : undefined
       );
+      if (draggedTab.group?.hasAttribute("split-view-group")) {
+        draggedTab = draggedTab.group.labelElement;
+      }
 
       if (this.#rtlMode) {
         tabs.reverse();
@@ -2610,7 +2683,7 @@
       let screenAxis = this.verticalMode ? "screenY" : "screenX";
       let size = this.verticalMode ? "height" : "width";
       let translateAxis = this.verticalMode ? "translateY" : "translateX";
-      let { width: tabWidth, height: tabHeight } = bounds(draggedTab);
+      let { width: tabWidth, height: tabHeight } = bounds(draggedTab.group?.hasAttribute("split-view-group") ? draggedTab.group : draggedTab);
       let translateX = event.screenX - dragData.screenX;
       let translateY = event.screenY - dragData.screenY;
 
@@ -2620,10 +2693,16 @@
       dragData.translateY = translateY;
 
       // Move the dragged tab based on the mouse position.
-      let firstTab = allTabs.at(this.#rtlMode ? -1 : 0);
-      let lastTab = allTabs.at(this.#rtlMode ? 0 : -1);
+      let firstTab = tabs.at(this.#rtlMode ? -1 : 0);
+      let lastTab = tabs.at(this.#rtlMode ? 0 : -1);
       let lastMovingTab = movingTabs.at(-1);
       let firstMovingTab = movingTabs[0];
+      if (lastMovingTab.group?.hasAttribute("split-view-group")) {
+        lastMovingTab = lastMovingTab.group;
+      }
+      if (firstMovingTab.group?.hasAttribute("split-view-group")) {
+        firstMovingTab = firstMovingTab.group;
+      }
       let endEdge = ele => ele[screenAxis] + bounds(ele)[size];
       let lastMovingTabScreen = endEdge(lastMovingTab);
       let firstMovingTabScreen = firstMovingTab[screenAxis];
@@ -2632,6 +2711,7 @@
       // Constrain the range over which the moving tabs can move between the first and last tab
       let firstBound = firstTab[screenAxis] - firstMovingTabScreen;
       let lastBound = endEdge(lastTab) - lastMovingTabScreen;
+      lastBound = gZenPinnedTabManager.getLastTabBound(lastBound, lastTab, isDraggingFolder);
 
       // Center the tab under the cursor if the tab is not under the cursor while dragging
       if (
@@ -2649,6 +2729,9 @@
           // Shift the `.tab-group-label-container` to shift the label element.
           item = item.parentElement;
         }
+        if (item.parentElement?.hasAttribute("split-view-group")) {
+          item = item.parentElement;
+        }
         item.style.transform = `${translateAxis}(${translate}px)`;
       }
 
@@ -2786,6 +2869,9 @@
             break;
           }
           let element = tabs[mid];
+          if (element?.group?.hasAttribute("split-view-group")) {
+            element = element.group.labelElement;
+          }
           let elementForSize = isTabGroupLabel(element)
             ? element.parentElement
             : element;
@@ -2805,6 +2891,8 @@
       };
 
       let dropElement = getOverlappedElement();
+      if (dropElement?.hasAttribute("split-view-group")) dropElement = dropElement.labelElement;
+      gZenPinnedTabManager.animateSeparatorMove(movingTabs, dropElement, isPinned, event);
 
       let newDropElementIndex;
       if (dropElement) {
@@ -2869,7 +2957,10 @@
       let shouldCreateGroupOnDrop;
       let dropBefore;
       if (dropElement) {
-        let dropElementForOverlap = isTabGroupLabel(dropElement)
+        if (dropElement?.group?.hasAttribute("split-view-group") || dropElement.hasAttribute("split-view-group")) {
+          dropElement = dropElement.group.labelElement ?? dropElement.labelElement;
+        }
+        let dropElementForOverlap = isTabGroupLabel(dropElement) && !dropElement.group?.hasAttribute("split-view-group")
           ? dropElement.parentElement
           : dropElement;
 
@@ -2889,7 +2980,7 @@
           ? Services.prefs.getIntPref(
               "browser.tabs.dragDrop.moveOverThresholdPercent"
             ) / 100
-          : 0.5;
+          : Services.prefs.getIntPref('zen.view.drag-and-drop.move-over-threshold') / 100;
         moveOverThreshold = Math.min(1, Math.max(0, moveOverThreshold));
         let shouldMoveOver = overlapPercent > moveOverThreshold;
         if (logicalForward && shouldMoveOver) {
@@ -2921,44 +3012,21 @@
 
         // If dragging a group over another group, don't make it look like it is
         // possible to drop the dragged group inside the other group.
-        if (
-          isTabGroupLabel(draggedTab) &&
-          dropElement?.group &&
-          !dropElement.group.collapsed
-        ) {
-          let overlappedGroup = dropElement.group;
-
-          if (isTabGroupLabel(dropElement)) {
-            dropBefore = true;
-            newDropElementIndex = dropElement.elementIndex;
-          } else {
-            dropBefore = false;
-            newDropElementIndex = overlappedGroup.tabs.at(-1).elementIndex + 1;
-          }
-
-          dropElement = overlappedGroup;
-        }
 
         // Constrain drop direction at the boundary between pinned and
         // unpinned tabs so that they don't mix together.
         let isOutOfBounds = isPinned
           ? dropElement.elementIndex >= numPinned
           : dropElement.elementIndex < numPinned;
-        if (isOutOfBounds) {
-          // Drop after last pinned tab
-          dropElement = this.ariaFocusableItems[numPinned - 1];
-          dropBefore = false;
-        }
       }
 
-      if (
-        gBrowser._tabGroupsEnabled &&
-        isTab(draggedTab) &&
-        !isPinned &&
-        (!numPinned || newDropElementIndex > numPinned)
-      ) {
+      if (isTab(draggedTab) || isTabGroupLabel(draggedTab)) {
         let dragOverGroupingThreshold = 1 - moveOverThreshold;
 
+        if (draggedTab && !dropElement?.group) {
+          gZenFolders.highlightGroupOnDragOver(null);
+        }
+
         // When dragging tab(s) over an ungrouped tab, signal to the user
         // that dropping the tab(s) will create a new tab group.
         shouldCreateGroupOnDrop =
@@ -2968,12 +3036,6 @@
           overlapPercent > dragOverGroupingThreshold;
 
         if (shouldCreateGroupOnDrop) {
-          this.#dragOverCreateGroupTimer = setTimeout(
-            () => this.#triggerDragOverCreateGroup(dragData, dropElement),
-            Services.prefs.getIntPref(
-              "browser.tabs.dragDrop.createGroup.delayMS"
-            )
-          );
         } else {
           this.removeAttribute("movingtab-createGroup");
           document
@@ -3000,19 +3062,14 @@
             dropElement = dropElementGroup;
             colorCode = undefined;
           } else if (isTabGroupLabel(dropElement)) {
-            if (dropBefore) {
-              // Dropping right before the tab group.
-              dropElement = dropElementGroup;
-              colorCode = undefined;
-            } else if (dropElementGroup.collapsed) {
-              // Dropping right after the collapsed tab group.
-              dropElement = dropElementGroup;
-              colorCode = undefined;
-            } else {
-              // Dropping right before the first tab in the tab group.
-              dropElement = dropElementGroup.tabs[0];
-              dropBefore = true;
-            }
+            ({ dropElement, colorCode, dropBefore } = gZenFolders.handleDragOverTabGroupLabel(
+              dropElement,
+              draggedTab,
+              overlapPercent,
+              movingTabs,
+              dropBefore,
+              colorCode
+            ));
           }
           this.#setDragOverGroupColor(colorCode);
           this.toggleAttribute("movingtab-ungroup", !colorCode);
@@ -3030,19 +3087,28 @@
       dragData.dropElement = dropElement;
       dragData.dropBefore = dropBefore;
       dragData.animDropElementIndex = newDropElementIndex;
-
+      gZenFolders.setFolderIndentation(movingTabs, dropElement);
       // Shift background tabs to leave a gap where the dragged tab
       // would currently be dropped.
       for (let item of tabs) {
-        if (item == draggedTab) {
+        if (item == draggedTab || (item.group?.hasAttribute("split-view-group") && item.group == draggedTab.group)) {
           continue;
         }
 
         let shift = getTabShift(item, newDropElementIndex);
         let transform = shift ? `${translateAxis}(${shift}px)` : "";
+        if (item.group?.hasAttribute("split-view-group")) {
+          item = item.group;
+        }
+        if (item.group?.hasAttribute("has-active") && draggedTab.group != item.group) {
+          item = item.group;
+        }
         if (isTabGroupLabel(item)) {
           // Shift the `.tab-group-label-container` to shift the label element.
           item = item.parentElement;
+          if (item.parentElement?.hasAttribute("split-view-group")) {
+            item = item.parentElement;
+          }
         }
         item.style.transform = transform;
       }
@@ -3095,12 +3161,14 @@
       );
     }
 
-    finishAnimateTabMove() {
-      if (!this.#isMovingTab()) {
+    finishAnimateTabMove(always = false) {
+      gZenPinnedTabManager.onDragFinish();
+      if (!this.#isMovingTab() && !always) {
         return;
       }
 
       this.#setMovingTabMode(false);
+      gZenFolders.highlightGroupOnDragOver(null);
 
       for (let item of this.ariaFocusableItems) {
         if (isTabGroupLabel(item)) {
@@ -3108,6 +3176,18 @@
           item = item.parentElement;
         }
         item.style.transform = "";
+        if (item.closest("zen-folder")?.hasAttribute("has-active")) item.closest("zen-folder").style.transform = "";
+        if (item.closest("zen-folder")?.hasAttribute("has-active")) {
+          for (let tab of item.closest("zen-folder").tabs) {
+            tab.style.transform = "";
+          }
+        }
+        if (item.closest("tab-group")?.hasAttribute("split-view-group")) item.closest("tab-group").style.transform = "";
+        if (item.closest("tab-group")?.hasAttribute("split-view-group")) {
+          for (let tab of item.closest("tab-group").tabs) {
+            tab.style.transform = "";
+          }
+        }
         item.removeAttribute("dragover-createGroup");
       }
       this.removeAttribute("movingtab-createGroup");
@@ -3129,16 +3209,15 @@
         tab.style.left = "";
         tab.style.top = "";
         tab.style.maxWidth = "";
-        tab.removeAttribute("dragtarget");
+        tab.removeAttribute("zen-dragtarget");
       }
       for (let label of draggedTabDocument.getElementsByClassName(
         "tab-group-label-container"
       )) {
         label.style.width = "";
-        label.style.height = "";
         label.style.left = "";
         label.style.top = "";
-        label.removeAttribute("dragtarget");
+        label.removeAttribute("zen-dragtarget");
       }
       let periphery = draggedTabDocument.getElementById(
         "tabbrowser-arrowscrollbox-periphery"
@@ -3211,7 +3290,7 @@
         let postTransitionCleanup = () => {
           movingTab._moveTogetherSelectedTabsData.animate = false;
         };
-        if (gReduceMotion) {
+        if (true || gReduceMotion) {
           postTransitionCleanup();
         } else {
           let onTransitionEnd = transitionendEvent => {
@@ -3384,7 +3463,7 @@
     }
 
     _notifyBackgroundTab(aTab) {
-      if (aTab.pinned || !aTab.visible || !this.overflowing) {
+      if (aTab.hasAttribute("zen-essential") || !aTab.visible || !this.overflowing) {
         return;
       }
 
@@ -3493,7 +3572,10 @@
     #getDragTarget(event, { ignoreSides = false } = {}) {
       let { target } = event;
       while (target) {
-        if (isTab(target) || isTabGroupLabel(target)) {
+        if (isTab(target) || isTabGroupLabel(target) || target?.classList?.contains("tab-group-label-container")) {
+          if (target.classList?.contains("tab-group-label-container")) {
+            target = target.querySelector(".tab-group-label");
+          }
           break;
         }
         target = target.parentNode;
@@ -3510,6 +3592,9 @@
           return null;
         }
       }
+      if (target?.group?.hasAttribute("split-view-group")) {
+        target = target.group.labelElement;
+      }
       return target;
     }
 
